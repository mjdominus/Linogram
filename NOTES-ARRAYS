HOW TO DEAL WITH ARRAYS

To generate constraint equations:

  1. Assemble param environment (already coded)
  2. Assemble constraint equations with arrays unexpanded
     Each equation is an EXPRESSION.
  3. For each expression:
     a. Substitute params into expression
     b. Identify index variables.  These are the variables that appear
        in the subscript portions of the expressions.  Any such
        variable that was declared as a feature will throw a fatal
        error.
     c. Associate a range and a closure with each index variable.
        This depends only on the type of the names which are
        subscripted by subscripts in which the variable appears.  For
        example, in the constraint a[i] = b[i+1], we infer range and
        closure for i based on the declarations of a and b.

        If the inferences don't all match, throw a failure.

        In a future version, intferences can be overridden by explicit
        index declarations.

     d. For each index variable, run an appropriate loop and perform
        index variable substitution on the expression.  If there are
        multiple index variables, use nested loops.

        For each resulting expression:
        i. Fold constants
        ii. Check for non-constant subscripts; fail if there are any
        iii. Collapse compound names to strings.  For example,
             [ ["a"], ["b", CON 3], ["c", CON 7] ] becomes "a.b[3].c[7]".

        The result is a single constraint equation.

ABOUT THE FORMAT OF NAMES 2011-02-28

Input syntax like "a.b[expr x].c[expr y]" should parse to something
like

        NAME: [ ["a"], ["b", (expr x)], ["c", (expr y)] ]

Variables in expr x and expr y get range inference.  We can decduce
the ranges very early because it is implicit at step 0 from the
declarations of a, a.b, a.b.c, etc.

Later, in step 3d(iii), these are collapsed to simple names.  This
fails unless the expressions have been reduced to constants.

RANGE INFERENCE 2011-02-28

Suppose we have

        number a[3], b[4];

then:

A.
        a[i] = b[i]

        Illegal, since i is inferred to be both 0..2 and 0..3.

B.
        a[i] = b[j]

        Okay; we get a double loop which equates each a[i] to each b[j].

C.
        a[i] = a[2*i]
        b[i] = b[3*i]

        Okay; the intferences are made per-constraint, and i can be
        inferred to have range 0..2 in the first constraint and 0..3
        in the second.

D.
        index i : 0..2;
        a[i] = b[i];

        Okay; an explicit index declaration overrides inference.  b[3]
        is left unconstrained.  The syntax of index declarations will
        look like:

         You thought that such declaratiobns could take an optional
         closed / open qualifier, but that is wrong; closure is a
         property of the object being subscripted, not the index.


INDEX DECLARATION SYNTAX 2011-03-01

Explicit index declarations are a little silly.  It will usually be
more convenient to use a syntax like this:

        a[i] = b[i] for i in 0..2

        a[i] = b[i] for i in 0..2, j in 2..4

INDEX DECLARATIONS MAY BE MORE URGENT THAN YOU THOUGHT

Suppose you want to draw the complete graph on 5 vertices.  Is this
possible without index declarations?  I can't think of a way.

        point P[5];
        line  E[10];

        E[i].start = P[i]
        E[i].end = P[i+1] for i in 0..4
        E[i].end = P[i+2] for i in 5..9

Actually I guess this would work:

        point P[5];
        line  E1[5], E2[5];

        E1[i].start = E2[i].start = P[i]
        E1[i].end = P[i+1]
        E2[i].end = P[i+2]

but splitting E seems sort of arbitrary.

You had similar worries about K_3,3., but it could be done like this:

        point L[3], R[3]
        line T[3], M[3], B[3]

        T[i].start = L[1]
        M[i].start = L[2]
        B[i].start = L[3]
        T[i].end = M[i].end = B[i].end = L[i]

Is that better than this?

        point L[3], R[3]
        line E[9]

        E[i].start = L[i % 3] for i in 0..8
        E[i].end   = R[i / 3] for i in 0..8

I think so, but it's certainly more verbose. One multiplies entities.
The other requires a weird computational trick.  On the other hand,
such tricks might be important in general.

