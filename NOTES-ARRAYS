HOW TO DEAL WITH ARRAYS

To generate constraint equations:

  1. Assemble param environment (already coded)
     See below, ASSEMBLE PARAM ENVIRONMENT
  2. Assemble constraint equations with arrays unexpanded
     Each equation is an EXPRESSION.
  3. For each expression:
     a. Substitute params into expression
     b. Identify index variables.  These are the variables that appear
        in the subscript portions of the expressions.  Any such
        variable that was declared as a feature will throw a fatal
        error.
     c. Associate a range and a closure with each index variable.
        This depends only on the type of the names which are
        subscripted by subscripts in which the variable appears.  For
        example, in the constraint a[i] = b[i+1], we infer range and
        closure for i based on the declarations of a and b.

        If the inferences don't all match, throw a failure.

        In a future version, inferences can be overridden by explicit
        index declarations.

     d. For each index variable, run an appropriate loop and perform
        index variable substitution on the expression.  If there are
        multiple index variables, use nested loops.

        For each resulting expression:
        i. Fold constants
        ii. Check for non-constant subscripts; fail if there are any
        iii. Collapse compound names to strings.  For example,
             [ ["a"], ["b", CON 3], ["c", CON 7] ] becomes "a.b[3].c[7]".

        The result is a single constraint equation.

ABOUT THE FORMAT OF NAMES 2011-02-28

Input syntax like "a.b[expr x].c[expr y]" should parse to something
like

        NAME: [ ["a"], ["b", (expr x)], ["c", (expr y)] ]

(2011-03-06 It already does this.)

Variables in expr x and expr y get range inference.  We can deduce
the ranges very early because it is implicit at step 0 from the
declarations of a, a.b, a.b.c, etc.

Later, in step 3d(iii), these are collapsed to simple names.  This
fails unless the expressions have been reduced to constants.

RANGE INFERENCE 2011-02-28

Suppose we have

        number a[3], b[4];

then:

A.
        a[i] = b[i]

        Illegal, since i is inferred to be both 0..2 and 0..3.

B.
        a[i] = b[j]

        Okay; we get a double loop which equates each a[i] to each b[j].

C.
        a[i] = a[2*i]
        b[i] = b[3*i]

        Okay; the inferences are made per-constraint, and i can be
        inferred to have range 0..2 in the first constraint and 0..3
        in the second.

D.
        index i : 0..2;
        a[i] = b[i];

        Okay; an explicit index declaration overrides inference.  b[3]
        is left unconstrained.  The syntax of index declarations will
        look like:

         You thought that such declarations could take an optional
         closed / open qualifier, but that is wrong; closure is a
         property of the object being subscripted, not the index.


INDEX DECLARATION SYNTAX 2011-03-01

Explicit index declarations are a little silly.  It will usually be
more convenient to use a syntax like this:

        a[i] = b[i] for i in 0..2

        a[i] = b[i] for i in 0..2, j in 2..4

INDEX DECLARATIONS MAY BE MORE URGENT THAN YOU THOUGHT

Suppose you want to draw the complete graph on 5 vertices.  Is this
possible without index declarations?  I can't think of a way.

        point P[5];
        line  E[10];

        E[i].start = P[i]
        E[i].end = P[i+1] for i in 0..4
        E[i].end = P[i+2] for i in 5..9

Actually I guess this would work:

        point P[5];
        line  E1[5], E2[5];

        E1[i].start = E2[i].start = P[i]
        E1[i].end = P[i+1]
        E2[i].end = P[i+2]

but splitting E seems sort of arbitrary.

You had similar worries about K_3,3., but it could be done like this:

        point L[3], R[3]
        line T[3], M[3], B[3]

        T[i].start = L[1]
        M[i].start = L[2]
        B[i].start = L[3]
        T[i].end = M[i].end = B[i].end = L[i]

Is that better than this?

        point L[3], R[3]
        line E[9]

        E[i].start = L[i % 3] for i in 0..8
        E[i].end   = R[i / 3] for i in 0..8

I think so, but it's certainly more verbose. One multiplies entities.
The other requires a weird computational trick.  On the other hand,
such tricks might be important in general.

ASSEMBLE PARAM ENVIRONMENT 2011-03-06

But what about params that are on subobjects of arrays? You can't
traverse the arrays until step 3d, but you need to assemble the param
enironment in step 1.  Also there might be something like:

           Point p[N](color = i);

So you need to have a recursion here: Assemble the param environment
that you can, in each component, and then recursively try to deduce
the bounds at in the subcomponents.

MUTUAL RECURSION 2011-07-08

Let's consider a simple example from the test suite:


        # array-063

        define snark {
          param number p = 13;
        }

        snark s[2];

We want the output to have

        s[0].p: 13
        s[1].p: 13

The current problem is that when the parameter gathering recurses
through the array, it doesn't take into  account that there are two
snarks, each with its own params.  It uses ->over, which is just plain
broken for arrays.

At the moment the recursion enters s, it can see that the type is an
array of snarks, and the declared size is the expression [CON 2].  In
general this expression might be quite complicated, and might depend
on parameters calculated elsewhere, but as a first cut it can try
resolving the expression to a compile-time constant, using that, and
then either 1. recursing separately into each array element, or
2. just expanding the returned parameters from { p => 13 } to
{ s{$_}.p => 13 for $_ in range(2) }.  The latter makes more sense to
me right now.

The logical place to do this is in ->my_subchunks.  At present, when
returning the subchunks, if any is an array, it returns the base type
instead of the array type, destroying the subscript information.  Is
this *ever* correct?

There are calls to ->my_subchunk as follows:

      1. In->drawables, where there is already a comment marking it as
      a bug.

      2. In-> all_leaf_subchunks. This is used only to generate
      initial synthetic constraints.  It seems to me it ought to
      generate one such for each array element.

      3. In ->over and ->over_list. These are used:

         a. all_constraint_equations.  See above.
         b. param_values.  That's what we're trying to fix.

So it appears that I should try having ->my_subchunks expand arrays
when possible.

(As a side note, the ->{up,over}{,_list} functions do not seem to be
used a lot; can I get rid of them, or at least simplify them?)

