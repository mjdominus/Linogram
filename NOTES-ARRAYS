Here's how to deal with arrays.

To generate constraint equations:

  1. Assemble param environment (already coded)
  2. Assemble constraint equations with arrays unexpanded
     Each equation is an EXPRESSION.
  3. For each expression:
     a. Substitute params into expression
     b. Identify index variables.  These are the variables that appear
        in the subscript portions of the expressions.  Any such
        variable that was declared as a feature will throw a fatal
        error.
     c. Associate a range and a closure with each index variable.
        This depends only on the type of the names which are
        subscripted by subscripts in which the variable appears.  For
        example, in the constraint a[i] = b[i+1], we infer range and
        closure for i based on the declarations of a and b.

        If the inferences don't all match, throw a failure.

        In a future version, intferences can be overridden by explicit
        index declarations.       

     d. For each index variable, run an appropriate loop and perform
        index variable substitution on the expression.  If there are
        multiple index variables, use nested loops.

        For each resulting expression:
        i. Fold constants
        ii. Check for non-constant subscripts; fail if there are any
        iii. Collapse compound names to strings.  For example,
             [ ["a"], ["b", CON 3], ["c", CON 7] ] becomes "a.b[3].c[7]".

        The result is a single constraint equation.


ABOUT THE FORMAT OF NAMES

Input syntax like "a.b[expr x].c[expr y]" should parse to something
like

        NAME: [ ["a"], ["b", (expr x)], ["c", (expr y)] ]

Variables in expr x and expr y get range inference.  We can decduce
the ranges very early because it is implicit at step 0 from the
declarations of a, a.b, a.b.c, etc.

Later, in step 3d(iii), these are collapsed to simple names.  This
fails unless the expressions have been reduced to constants.

RANGE INFERENCE

Suppose we have

        number a[3], b[4];

then:

A.
        a[i] = b[i]

        Illegal, since i is inferred to be both 0..2 and 0..3.

B.
        a[i] = b[j]

        Okay; we get a double loop which equates each a[i] to each b[j].

C.
        a[i] = a[2*i]
        b[i] = b[3*i]

        Okay; the intferences are made per-constraint, and i can be
        inferred to have range 0..2 in the first constraint and 0..3
        in the second.

D.
        index i : 0..2;
        a[i] = b[i];

        Okay; an explicit index declaration overrides inference.  b[3]
        is left unconstrained.  The syntax of index declarations will
        look like:

         You thought that such declaratiobns could take an optional
         closed / open qualifier, but that is wrong; closure is a
         property of the object being subscripted, not the index.



